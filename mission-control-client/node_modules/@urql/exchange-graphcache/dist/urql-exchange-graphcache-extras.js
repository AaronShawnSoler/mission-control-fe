"use strict";

var core = require("urql/core");

function _extends() {
  return (_extends = Object.assign || function(a) {
    for (var f = 1; f < arguments.length; f++) {
      var c, d = arguments[f];
      for (c in d) {
        Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
      }
    }
    return a;
  }).apply(this, arguments);
}

var defaultPageInfo = {
  __typename: "PageInfo",
  endCursor: null,
  startCursor: null,
  hasNextPage: !1,
  hasPreviousPage: !1
}, ensureKey = function(a) {
  return "string" == typeof a ? a : null;
}, concatEdges = function(a, f, d) {
  for (var c = new Set, b = 0, g = f.length; b < g; b++) {
    var p = a.resolve(f[b], "node");
    "string" == typeof p && c.add(p);
  }
  f = f.slice();
  b = 0;
  for (g = d.length; b < g; b++) {
    var k = a.resolve(p = d[b], "node");
    "string" != typeof k || c.has(k) || (c.add(k), f.push(p));
  }
  return f;
}, compareArgs = function(a, f) {
  for (var d in f) {
    if ("first" !== d && "last" !== d && "after" !== d && "before" !== d) {
      if (!(d in a)) {
        return !1;
      }
      var c = a[d], b = f[d];
      if (typeof c != typeof b || "object" != typeof c ? c !== b : core.stringifyVariables(c) !== core.stringifyVariables(b)) {
        return !1;
      }
    }
  }
  return !0;
}, getPage = function(a, f, d) {
  var c = ensureKey(a.resolveFieldByKey(f, d));
  if (!c) {
    return null;
  }
  f = a.resolve(c, "__typename");
  d = a.resolve(c, "edges") || [];
  if ("string" != typeof f) {
    return null;
  }
  f = {
    __typename: f,
    edges: d,
    pageInfo: defaultPageInfo
  };
  var b = a.resolve(c, "pageInfo");
  if ("string" == typeof b) {
    c = ensureKey(a.resolve(b, "__typename"));
    var g = ensureKey(a.resolve(b, "endCursor")), p = ensureKey(a.resolve(b, "startCursor")), k = a.resolve(b, "hasNextPage");
    b = a.resolve(b, "hasPreviousPage");
    null === (c = f.pageInfo = {
      __typename: "string" == typeof c ? c : "PageInfo",
      hasNextPage: "boolean" == typeof k ? k : !!g,
      hasPreviousPage: "boolean" == typeof b ? b : !!p,
      endCursor: g,
      startCursor: p
    }).endCursor && (g = d[d.length - 1]) && (g = a.resolve(g, "cursor"), c.endCursor = ensureKey(g));
    null === c.startCursor && (d = d[0]) && (a = a.resolve(d, "cursor"), c.startCursor = ensureKey(a));
  }
  return f;
};

exports.relayPagination = function(a) {
  void 0 === a && (a = {});
  var f = a.mergeMode || "inwards";
  return function(a, c, b, g) {
    var d = g.fieldName, k = b.inspectFields(a = g.parentKey).filter((function(b) {
      return b.fieldName === d;
    })), w = k.length;
    if (0 !== w) {
      for (var u = null, q = [], n = [], h = _extends({}, defaultPageInfo), m = 0; m < w; m++) {
        var l = k[m], e = l.fieldKey;
        null !== (l = l.arguments) && compareArgs(c, l) && (null !== (e = getPage(b, a, e)) && ("inwards" === f && "number" == typeof l.last && "number" == typeof l.first ? (h = e.edges.slice(0, l.first + 1), 
        l = e.edges.slice(-l.last), q = concatEdges(b, q, h), n = concatEdges(b, l, n), 
        h = e.pageInfo) : l.after ? (q = concatEdges(b, q, e.edges), h.endCursor = e.pageInfo.endCursor, 
        h.hasNextPage = e.pageInfo.hasNextPage) : l.before ? (n = concatEdges(b, e.edges, n), 
        h.startCursor = e.pageInfo.startCursor, h.hasPreviousPage = e.pageInfo.hasPreviousPage) : ("number" == typeof l.last ? n = concatEdges(b, n, e.edges) : q = concatEdges(b, q, e.edges), 
        h = e.pageInfo), e.pageInfo.__typename !== h.__typename && (h.__typename = e.pageInfo.__typename), 
        u !== e.__typename && (u = e.__typename)));
      }
      if ("string" == typeof u) {
        if (!ensureKey(b.resolve(a, d, c))) {
          if (void 0 === g.schemaPredicates) {
            return;
          }
          g.partial = !0;
        }
        return {
          __typename: u,
          edges: "inwards" === f ? concatEdges(b, q, n) : concatEdges(b, n, q),
          pageInfo: {
            __typename: h.__typename,
            endCursor: h.endCursor,
            startCursor: h.startCursor,
            hasNextPage: h.hasNextPage,
            hasPreviousPage: h.hasPreviousPage
          }
        };
      }
    }
  };
};

exports.simplePagination = function(a) {
  void 0 === a && (a = {});
  var f = a.offsetArgument;
  void 0 === f && (f = "skip");
  var d = a.limitArgument;
  void 0 === d && (d = "limit");
  var c = function(b, a) {
    for (var c in a) {
      if (c !== f && c !== d) {
        if (!(c in b)) {
          return !1;
        }
        var k = b[c], g = a[c];
        if (typeof k != typeof g || "object" != typeof k ? k !== g : core.stringifyVariables(k) !== core.stringifyVariables(g)) {
          return !1;
        }
      }
    }
    return !0;
  };
  return function(b, a, d, k) {
    var g = k.fieldName, p = d.inspectFields(b = k.parentKey).filter((function(a) {
      return a.fieldName === g;
    })), q = p.length;
    if (0 !== q) {
      for (var n = new Set, h = [], m = null, l = 0; l < q; l++) {
        var e = p[l], r = e.fieldKey;
        if (null !== (e = e.arguments) && c(a, e) && (r = d.resolveFieldByKey(b, r), e = e[f], 
        null !== r && 0 !== r.length && "number" == typeof e)) {
          if (!m || e > m) {
            for (m = 0; m < r.length; m++) {
              var t = r[m];
              n.has(t) || (h.push(t), n.add(t));
            }
          } else {
            m = [];
            for (t = 0; t < r.length; t++) {
              var v = r[t];
              n.has(v) || (m.push(v), n.add(v));
            }
            h = m.concat(h);
          }
          m = e;
        }
      }
      if (d.resolve(b, g, a)) {
        return h;
      }
      if (void 0 !== k.schemaPredicates) {
        return k.partial = !0, h;
      }
    }
  };
};
//# sourceMappingURL=urql-exchange-graphcache-extras.js.map
