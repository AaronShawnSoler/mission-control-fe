import { DocumentNode } from 'graphql';
import { Cache, FieldInfo, ResolverConfig, DataField, Variables, Data, QueryInput, UpdatesConfig, OptimisticMutationConfig, KeyingConfig } from '../types';
import { SchemaPredicates } from '../ast';
import * as InMemoryData from './data';
declare type RootField = 'query' | 'mutation' | 'subscription';
export declare class Store implements Cache {
    data: InMemoryData.InMemoryData;
    resolvers: ResolverConfig;
    updates: UpdatesConfig;
    optimisticMutations: OptimisticMutationConfig;
    keys: KeyingConfig;
    schemaPredicates?: SchemaPredicates;
    rootFields: {
        query: string;
        mutation: string;
        subscription: string;
    };
    rootNames: {
        [name: string]: RootField;
    };
    constructor(schemaPredicates?: SchemaPredicates, resolvers?: ResolverConfig, updates?: Partial<UpdatesConfig>, optimisticMutations?: OptimisticMutationConfig, keys?: KeyingConfig);
    gcScheduled: boolean;
    gc: () => void;
    keyOfField: (fieldName: string, args?: Variables | null | undefined) => string;
    getRootKey(name: RootField): string;
    keyOfEntity(data: Data): string | null;
    resolveFieldByKey(entity: Data | string | null, fieldKey: string): DataField;
    resolve(entity: Data | string | null, field: string, args?: Variables): DataField;
    invalidateQuery(query: string | DocumentNode, variables?: Variables): void;
    inspectFields(entity: Data | string | null): FieldInfo[];
    updateQuery(input: QueryInput, updater: (data: Data | null) => Data | null): void;
    readQuery(input: QueryInput): Data | null;
    readFragment(dataFragment: DocumentNode, entity: string | Data, variables?: Variables): Data | null;
    writeFragment(dataFragment: DocumentNode, data: Data, variables?: Variables): void;
}
export {};
