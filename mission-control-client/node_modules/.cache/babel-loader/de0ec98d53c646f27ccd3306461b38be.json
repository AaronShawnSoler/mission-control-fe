{"ast":null,"code":"import { share, onPush, takeWhile, toPromise, take } from \"wonka\";\nimport { GraphQLError, parse, print, visit, Kind } from \"graphql\";\n\nfunction _extends() {\n  return (_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  }).apply(this, arguments);\n}\n\nvar rehydrateGraphQlError = function (error) {\n  if (\"string\" == typeof error) {\n    return new GraphQLError(error);\n  } else if (\"object\" == typeof error && error.message) {\n    return new GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error, error.extensions || {});\n  } else {\n    return error;\n  }\n};\n\nfunction _toString() {\n  return this.message;\n}\n\nvar CombinedError = function (Error) {\n  function CombinedError(ref) {\n    var networkError = ref.networkError;\n    var response = ref.response;\n    var normalizedGraphQLErrors = (ref.graphQLErrors || []).map(rehydrateGraphQlError);\n\n    var message = function (networkErr, graphQlErrs) {\n      var error = \"\";\n\n      if (void 0 !== networkErr) {\n        return error = \"[Network] \" + networkErr.message;\n      }\n\n      if (void 0 !== graphQlErrs) {\n        graphQlErrs.forEach(function _ref(err) {\n          error += \"[GraphQL] \" + err.message + \"\\n\";\n        });\n      }\n\n      return error.trim();\n    }(networkError, normalizedGraphQLErrors);\n\n    Error.call(this, message);\n    this.name = \"CombinedError\";\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  if (Error) {\n    CombinedError.__proto__ = Error;\n  }\n\n  (CombinedError.prototype = Object.create(Error && Error.prototype)).constructor = CombinedError;\n  CombinedError.prototype.toString = _toString;\n  return CombinedError;\n}(Error);\n\nvar phash = function (h, x) {\n  h |= 0;\n\n  for (var i = 0, l = 0 | x.length; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\nvar seen = new Set();\n\nvar stringify = function (x) {\n  if (void 0 === x) {\n    return \"\";\n  } else if (\"number\" == typeof x) {\n    return isFinite(x) ? \"\" + x : \"null\";\n  } else if (\"object\" != typeof x) {\n    return JSON.stringify(x);\n  } else if (null === x) {\n    return \"null\";\n  } else if (x.toJSON) {\n    return x.toJSON();\n  }\n\n  var out = \"\";\n\n  if (Array.isArray(x)) {\n    out = \"[\";\n\n    for (var i = 0, l = x.length; i < l; i++) {\n      if (i > 0) {\n        out += \",\";\n      }\n\n      var value = stringify(x[i]);\n      out += value.length > 0 ? value : \"null\";\n    }\n\n    return out += \"]\";\n  } else if (seen.has(x)) {\n    throw new TypeError(\"Converting circular structure to JSON\");\n  }\n\n  var keys = Object.keys(x).sort();\n  seen.add(x);\n  out = \"{\";\n\n  for (var i$1 = 0, l$1 = keys.length; i$1 < l$1; i$1++) {\n    var key = keys[i$1];\n    var value$1 = stringify(x[key]);\n\n    if (0 !== value$1.length) {\n      if (out.length > 1) {\n        out += \",\";\n      }\n\n      out += stringify(key) + \":\" + value$1;\n    }\n  }\n\n  seen.delete(x);\n  return out += \"}\";\n};\n\nvar stringifyVariables = function (x) {\n  seen.clear();\n  return stringify(x);\n};\n\nvar hashQuery = function (q) {\n  return x = q.replace(/[\\s,]+/g, \" \").trim(), phash(5381, x) >>> 0;\n  var x;\n};\n\nvar docs = Object.create(null);\n\nvar createRequest = function (q, vars) {\n  var key;\n  var query;\n\n  if (\"string\" == typeof q) {\n    key = hashQuery(q);\n    query = void 0 !== docs[key] ? docs[key] : parse(q);\n  } else if (void 0 !== q.__key) {\n    key = q.__key;\n    query = q;\n  } else {\n    key = hashQuery(print(q));\n    query = void 0 !== docs[key] ? docs[key] : q;\n  }\n\n  docs[key] = query;\n  query.__key = key;\n  return {\n    key: vars ? phash(key, stringifyVariables(vars)) >>> 0 : key,\n    query: query,\n    variables: vars || {}\n  };\n};\n\nvar addMetadata = function (source, meta) {\n  return _extends(_extends({}, source), {\n    context: _extends(_extends({}, source.context), {\n      meta: _extends(_extends({}, source.context.meta), meta)\n    })\n  });\n};\n\nvar makeResult = function (operation, result, response) {\n  return {\n    operation: operation,\n    data: result.data,\n    error: Array.isArray(result.errors) ? new CombinedError({\n      graphQLErrors: result.errors,\n      response: response\n    }) : void 0,\n    extensions: \"object\" == typeof result.extensions && null !== result.extensions ? result.extensions : void 0\n  };\n};\n\nvar makeErrorResult = function (operation, error, response) {\n  return {\n    operation: operation,\n    data: void 0,\n    error: new CombinedError({\n      networkError: error,\n      response: response\n    }),\n    extensions: void 0\n  };\n};\n\nvar collectTypes = function (obj, types) {\n  if (void 0 === types) {\n    types = [];\n  }\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function _ref(inner) {\n      collectTypes(inner, types);\n    });\n  } else if (\"object\" == typeof obj && null !== obj) {\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        var val = obj[key];\n\n        if (\"__typename\" === key && \"string\" == typeof val) {\n          types.push(val);\n        } else if (\"object\" == typeof val && null !== val) {\n          collectTypes(val, types);\n        }\n      }\n    }\n  }\n\n  return types;\n};\n\nfunction _ref2(v, i, a) {\n  return a.indexOf(v) === i;\n}\n\nvar collectTypesFromResponse = function (response) {\n  return collectTypes(response).filter(_ref2);\n};\n\nfunction _ref3(s) {\n  return \"Field\" === s.kind && \"__typename\" === s.name.value;\n}\n\nvar formatNode = function (n) {\n  if (void 0 === n.selectionSet) {\n    return !1;\n  }\n\n  if (n.selectionSet.selections.some(_ref3)) {\n    return n;\n  }\n\n  return _extends(_extends({}, n), {\n    selectionSet: _extends(_extends({}, n.selectionSet), {\n      selections: n.selectionSet.selections.concat([{\n        kind: Kind.FIELD,\n        name: {\n          kind: Kind.NAME,\n          value: \"__typename\"\n        }\n      }])\n    })\n  });\n};\n\nvar formatDocument = function (astNode) {\n  return visit(astNode, {\n    Field: formatNode,\n    InlineFragment: formatNode\n  });\n};\n\nvar toSuspenseSource = function (source) {\n  return function (sink) {\n    var shared = share(source);\n    var hasResult = !1;\n    var hasSuspended = !1;\n    onPush(function () {\n      return hasResult = !0;\n    })(takeWhile(function () {\n      return !hasSuspended;\n    })(shared))(sink);\n\n    if (!hasResult) {\n      hasSuspended = !0;\n      sink(0);\n      throw toPromise(take(1)(shared));\n    }\n  };\n};\n\nfunction withPromise(source$) {\n  source$.toPromise = function () {\n    return toPromise(take(1)(source$));\n  };\n\n  return source$;\n}\n\nexport { CombinedError as C, _extends as _, addMetadata as a, makeErrorResult as b, collectTypesFromResponse as c, createRequest as d, formatDocument as f, makeResult as m, stringifyVariables as s, toSuspenseSource as t, withPromise as w };","map":{"version":3,"sources":["../../src/utils/error.ts","../../src/utils/hash.ts","../../src/utils/stringifyVariables.ts","../../src/utils/request.ts","../../src/utils/result.ts","../../src/utils/typenames.ts","../../src/utils/toSuspenseSource.ts","../../src/utils/withPromise.ts"],"names":["networkErr","graphQlErrs","error","undefined","message","forEach","err","trim","const","rehydrateGraphQlError","GraphQLError","nodes","source","positions","path","extensions","CombinedError","Error","normalizedGraphQLErrors","map","generateErrorMessage","networkError","super","name","graphQLErrors","response","toString","this","phash","h","x","let","i","l","length","charCodeAt","seen","Set","stringify","isFinite","JSON","toJSON","out","Array","isArray","value","has","TypeError","keys","Object","sort","add","key","delete","stringifyVariables","clear","hashQuery","q","replace","docs","create","createRequest","vars","query","parse","print","variables","addMetadata","meta","context","makeResult","operation","result","data","errors","makeErrorResult","collectTypes","obj","types","inner","prototype","hasOwnProperty","call","val","push","collectTypesFromResponse","filter","v","a","indexOf","formatNode","n","selectionSet","selections","some","s","kind","Kind","FIELD","NAME","formatDocument","astNode","visit","Field","InlineFragment","toSuspenseSource","sink","shared","share","hasResult","hasSuspended","takeWhile","onPush","take","toPromise","withPromise","source$"],"mappings":"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","sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | GraphQLError | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nexport const phash = (h: number, x: string): number => {\n  h = h | 0;\n  for (let i = 0, l = x.length | 0; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\n// This is a djb2 hashing function\nexport const hash = (x: string): number => phash(5381 | 0, x) >>> 0;\n","const seen = new Set();\n\nconst stringify = (x: any): string => {\n  if (x === undefined) {\n    return '';\n  } else if (typeof x == 'number') {\n    return isFinite(x) ? '' + x : 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x);\n  } else if (x === null) {\n    return 'null';\n  } else if (x.toJSON) {\n    return x.toJSON();\n  }\n\n  let out = '';\n  if (Array.isArray(x)) {\n    out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  } else if (seen.has(x)) {\n    throw new TypeError('Converting circular structure to JSON');\n  }\n\n  const keys = Object.keys(x).sort();\n\n  seen.add(x);\n  out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value.length !== 0) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { DocumentNode, parse, print } from 'graphql';\nimport { hash, phash } from './hash';\nimport { stringifyVariables } from './stringifyVariables';\nimport { GraphQLRequest, Operation, OperationContext } from '../types';\n\ninterface Documents {\n  [key: number]: DocumentNode;\n}\n\nconst hashQuery = (q: string): number => hash(q.replace(/[\\s,]+/g, ' ').trim());\n\nconst docs: Documents = Object.create(null);\nconst keyProp = '__key';\n\nexport const createRequest = (\n  q: string | DocumentNode,\n  vars?: object\n): GraphQLRequest => {\n  let key: number;\n  let query: DocumentNode;\n  if (typeof q === 'string') {\n    key = hashQuery(q);\n    query = docs[key] !== undefined ? docs[key] : parse(q);\n  } else if ((q as any)[keyProp] !== undefined) {\n    key = (q as any)[keyProp];\n    query = q;\n  } else {\n    key = hashQuery(print(q));\n    query = docs[key] !== undefined ? docs[key] : q;\n  }\n\n  docs[key] = query;\n  (query as any)[keyProp] = key;\n\n  return {\n    key: vars ? phash(key, stringifyVariables(vars)) >>> 0 : key,\n    query,\n    variables: vars || {},\n  };\n};\n\n/** Spreads the provided metadata to the source operation's meta property in context.  */\nexport const addMetadata = (\n  source: Operation,\n  meta: Exclude<OperationContext['meta'], undefined>\n) => ({\n  ...source,\n  context: {\n    ...source.context,\n    meta: {\n      ...source.context.meta,\n      ...meta,\n    },\n  },\n});\n","import { Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: any,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: result.data,\n  error: Array.isArray(result.errors)\n    ? new CombinedError({\n        graphQLErrors: result.errors,\n        response,\n      })\n    : undefined,\n  extensions:\n    typeof result.extensions === 'object' && result.extensions !== null\n      ? result.extensions\n      : undefined,\n});\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import {\n  DocumentNode,\n  FieldNode,\n  InlineFragmentNode,\n  Kind,\n  visit,\n} from 'graphql';\n\ninterface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (obj: EntityLike | EntityLike[], types: string[] = []) => {\n  if (Array.isArray(obj)) {\n    obj.forEach(inner => {\n      collectTypes(inner, types);\n    });\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        const val = obj[key];\n        if (key === '__typename' && typeof val === 'string') {\n          types.push(val);\n        } else if (typeof val === 'object' && val !== null) {\n          collectTypes(val, types);\n        }\n      }\n    }\n  }\n\n  return types;\n};\n\nexport const collectTypesFromResponse = (response: object) =>\n  collectTypes(response as EntityLike).filter((v, i, a) => a.indexOf(v) === i);\n\nconst formatNode = (n: FieldNode | InlineFragmentNode) => {\n  if (n.selectionSet === undefined) {\n    return false;\n  }\n\n  if (\n    n.selectionSet.selections.some(\n      s => s.kind === 'Field' && s.name.value === '__typename'\n    )\n  ) {\n    return n;\n  }\n\n  return {\n    ...n,\n    selectionSet: {\n      ...n.selectionSet,\n      selections: [\n        ...n.selectionSet.selections,\n        {\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: '__typename',\n          },\n        },\n      ],\n    },\n  };\n};\n\nexport const formatDocument = (astNode: DocumentNode) =>\n  visit(astNode, {\n    Field: formatNode,\n    InlineFragment: formatNode,\n  });\n","import { pipe, share, onPush, toPromise, takeWhile, take, Source } from 'wonka';\n\n/** This converts a Source to a suspense Source; It will forward the first result synchronously or throw a promise that resolves when the result becomes available */\nexport const toSuspenseSource = <T>(source: Source<T>): Source<T> => sink => {\n  const shared = share(source);\n  let hasResult = false;\n  let hasSuspended = false;\n\n  pipe(\n    shared,\n    takeWhile(() => !hasSuspended),\n    onPush(() => (hasResult = true))\n  )(sink);\n\n  if (!hasResult) {\n    hasSuspended = true;\n    sink(0); /* End */\n    throw pipe(shared, take(1), toPromise);\n  }\n};\n","import { Source, pipe, toPromise, take } from 'wonka';\nimport { PromisifiedSource } from '../types';\n\nexport function withPromise<T>(source$: Source<T>): PromisifiedSource<T> {\n  (source$ as PromisifiedSource<T>).toPromise = () =>\n    pipe(\n      source$,\n      take(1),\n      toPromise\n    );\n  return source$ as PromisifiedSource<T>;\n}\n"]},"metadata":{},"sourceType":"module"}